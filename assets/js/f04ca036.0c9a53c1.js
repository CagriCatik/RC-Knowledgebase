"use strict";(self.webpackChunkrc_knowledgebase=self.webpackChunkrc_knowledgebase||[]).push([[806],{7854:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"controller/flight-controller/flight_time_measure","title":"How to measure the Flight Time","description":"1. Overview of the Approach","source":"@site/docs/04_controller/01_flight-controller/flight_time_measure.md","sourceDirName":"04_controller/01_flight-controller","slug":"/controller/flight-controller/flight_time_measure","permalink":"/RC-Knowledgebase/docs/controller/flight-controller/flight_time_measure","draft":false,"unlisted":false,"editUrl":"https://github.com/CagriCatik/RC-Knowledgebase/tree/main/docs/04_controller/01_flight-controller/flight_time_measure.md","tags":[],"version":"current","frontMatter":{},"sidebar":"controllerSidebar","previous":{"title":"Flight Time Calculation","permalink":"/RC-Knowledgebase/docs/controller/flight-controller/flight-time-calculation"},"next":{"title":"RC Controller","permalink":"/RC-Knowledgebase/docs/category/rc-controller"}}');var t=r(4848),s=r(8453);const l={},o="How to measure the Flight Time",a={},c=[{value:"<strong>1. Overview of the Approach</strong>",id:"1-overview-of-the-approach",level:2},{value:"<strong>2. Hardware Setup</strong>",id:"2-hardware-setup",level:2},{value:"<strong>3. Firmware Logic</strong>",id:"3-firmware-logic",level:2},{value:"<strong>4. Dealing with Voltage Readings</strong>",id:"4-dealing-with-voltage-readings",level:2},{value:"<strong>5. Practical Considerations</strong>",id:"5-practical-considerations",level:2},{value:"<strong>6. Summary</strong>",id:"6-summary",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"how-to-measure-the-flight-time",children:"How to measure the Flight Time"})}),"\n",(0,t.jsx)(n.h2,{id:"1-overview-of-the-approach",children:(0,t.jsx)(n.strong,{children:"1. Overview of the Approach"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Measure Battery Current"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use a ",(0,t.jsx)(n.strong,{children:"current sensor"})," (e.g., ACS712, INA219, or similar Hall-effect/voltage-shunt-based sensor) that outputs an analog or digital reading proportional to the instantaneous current flowing from the battery."]}),"\n",(0,t.jsx)(n.li,{children:"The microcontroller reads these values at a regular interval."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Integrate Current Over Time"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Every time you read the current, you multiply by the elapsed time to figure out \u201chow many mAh\u201d have been consumed in that interval. Summing these intervals gives you the total capacity used so far."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Estimate Remaining Capacity"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Knowing the battery\u2019s nominal capacity (e.g., 1500mAh) minus the consumed mAh gives an approximation of remaining capacity."}),"\n",(0,t.jsx)(n.li,{children:"You can then infer an estimated \u201cremaining flight time\u201d from the current consumption rate."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Display or Transmit Data"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Show the remaining battery capacity and/or flight time on an onboard display (LCD/OLED) or send telemetry back to a ground station or flight controller."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Refinements"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Measure battery voltage as well to catch low-voltage conditions (voltage sag)."}),"\n",(0,t.jsx)(n.li,{children:"Factor in battery health, temperature, and other practical aspects to refine accuracy."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"2-hardware-setup",children:(0,t.jsx)(n.strong,{children:"2. Hardware Setup"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"2.1 Current Sensor"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Examples"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ACS712"}),": Analog output, simple but can be noisy."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"INA219"}),": I\xb2C digital sensor, more accurate, measures both current and voltage."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"INA260"}),", ",(0,t.jsx)(n.strong,{children:"INA3221"}),", or similar integrated power monitors also exist."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Wiring"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Place the sensor in series with your battery\u2019s positive lead (or negative lead, depending on sensor type)."}),"\n",(0,t.jsx)(n.li,{children:"If it\u2019s an analog sensor like ACS712, connect its analog output pin to an ADC (Analog-to-Digital Converter) pin on the microcontroller."}),"\n",(0,t.jsx)(n.li,{children:"If it\u2019s a digital sensor like INA219, connect SDA and SCL to your microcontroller\u2019s I\xb2C bus pins (plus ground and VIN)."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Microcontroller"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Arduino Uno, STM32 \u201cBlue Pill,\u201d ESP32, or any board with an ADC or I\xb2C interface."}),"\n",(0,t.jsx)(n.li,{children:"Ensure the microcontroller\u2019s operating voltage and logic levels are compatible with the sensor."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"3-firmware-logic",children:(0,t.jsx)(n.strong,{children:"3. Firmware Logic"})}),"\n",(0,t.jsxs)(n.p,{children:["The core idea is to perform ",(0,t.jsx)(n.strong,{children:"periodic readings"})," of the current, integrate over time, and then calculate remaining flight time. Below is a conceptual Arduino-style pseudo-code (applicable to many microcontrollers with minor tweaks)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'/*****************************************************\n * Example: Using an INA219 sensor (I\xb2C) or ACS712 (analog)\n * For INA219, you can use a library like Adafruit_INA219.\n * For ACS712, you read from analog pin and convert to current.\n *****************************************************/\n\n##include <Wire.h>\n// ##include <Adafruit_INA219.h>  // If using an INA219 library\n\n// Adafruit_INA219 ina219;  // If using the INA219\n// or define the analog pin if using ACS712\nconst int CURRENT_SENSOR_PIN = A0;  // e.g., for ACS712 on Arduino\n\n// Battery capacity in mAh\nfloat batteryCapacity_mAh = 1500.0;  // Example 1500mAh battery\n\n// Variables for integration\nvolatile float consumed_mAh = 0.0;  // will track how much capacity used\nunsigned long lastUpdateTime = 0;   // in milliseconds\n\n// For flight-time estimation\nfloat averageCurrentDraw_A = 0.0;  // track average current\nfloat flightTimeLeft_minutes = 0.0;  // estimated\n\n// Constants\nconst float samplingInterval_ms = 100.0;  // read current every 100ms\nconst bool use80PercentRule = true;       // only use 80% of total capacity?\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();  // If using I2C sensor\n  // ina219.begin();  // If using INA219 library\n\n  lastUpdateTime = millis();\n  // Optionally, calibrate the sensor or zero offsets if needed.\n}\n\nvoid loop() {\n  unsigned long currentTime = millis();\n  \n  // Check if it\'s time to sample\n  if(currentTime - lastUpdateTime >= samplingInterval_ms) {\n    // Step 1: Read current (in amperes)\n    float current_A = 0.0;\n\n    // --- If using INA219 ---\n    // current_A = ina219.getCurrent_mA() / 1000.0; // convert mA to A\n\n    // --- If using ACS712 (example) ---\n    // int sensorValue = analogRead(CURRENT_SENSOR_PIN);\n    // float voltage = (sensorValue / 1023.0) * 5.0; // for Arduino 5V reference\n    // Convert \'voltage\' to \'current_A\' based on ACS712 calibration.\n    // e.g., for ACS712 5A module, 185 mV/A sensitivity, offset at ~2.5V\n    // current_A = (voltage - 2.5) / 0.185; \n\n    // [Replace with actual calibration formula for your sensor]\n\n    // Step 2: Time elapsed in hours since last update\n    float elapsed_s = (currentTime - lastUpdateTime) / 1000.0; // in seconds\n    float elapsed_h = elapsed_s / 3600.0; // convert to hours\n\n    // Step 3: Integrate to find how many Ah used in this interval\n    float used_Ah = current_A * elapsed_h;\n\n    // Step 4: Convert to mAh\n    float used_mAh = used_Ah * 1000.0;\n\n    // Step 5: Add to total consumed\n    consumed_mAh += used_mAh;\n\n    // Step 6: Recalculate flight time left\n    // (assuming average current remains about the same)\n    float effectiveCapacity_mAh = (use80PercentRule) ? (batteryCapacity_mAh * 0.8) : batteryCapacity_mAh;\n    float remaining_mAh = effectiveCapacity_mAh - consumed_mAh;\n    if (remaining_mAh < 0) {\n      remaining_mAh = 0; // can\'t be negative\n    }\n\n    // Current average usage: \n    // (We can do a rolling average or simply use current_A if we assume stable flight)\n    // For simplicity, let\'s assume current_A is representative\n    if(current_A > 0.1) {  // Avoid divide-by-zero if the drone is idle or sensor is noise\n      // Flight time left (in hours) = remaining_mAh / 1000 / current_A\n      float flightTimeLeft_h = (remaining_mAh / 1000.0) / current_A;\n      flightTimeLeft_minutes = flightTimeLeft_h * 60.0;\n    } else {\n      // If current_A is almost 0, e.g. idle on ground\n      flightTimeLeft_minutes = 9999; // or some large number\n    }\n\n    // Debug or telemetry output\n    Serial.print("Current (A): ");\n    Serial.print(current_A, 2);\n    Serial.print(" | Used (mAh): ");\n    Serial.print(consumed_mAh, 2);\n    Serial.print(" | Remaining (mAh): ");\n    Serial.print(effectiveCapacity_mAh - consumed_mAh, 2);\n    Serial.print(" | Est. Flight Time Left (min): ");\n    Serial.println(flightTimeLeft_minutes, 1);\n\n    // Update timer\n    lastUpdateTime = currentTime;\n  }\n\n  // Other code (e.g., controlling the drone, reading sensors, etc.) can go here.\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points in the Code"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Sampling Interval"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We read the current every 100ms in this example (",(0,t.jsx)(n.code,{children:"samplingInterval_ms"}),"). You can choose a faster or slower rate depending on how quickly your current draw changes."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Converting ADC Value to Amperes"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each current sensor has its own sensitivity and offset. For example, the ACS712 5A module is around 185mV per amp with a 2.5V quiescent output at 0A. You\u2019ll need to calibrate this formula for accurate readings."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"80% Rule"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We apply ",(0,t.jsx)(n.code,{children:"batteryCapacity_mAh * 0.8"})," to protect the battery from over-discharge. You can disable it by setting ",(0,t.jsx)(n.code,{children:"use80PercentRule = false"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Average Current vs. Instantaneous Current"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In the example, we use the instantaneous current from each cycle to estimate flight time. A more refined approach might maintain a rolling average of the last few seconds of current readings."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Flight Time Calculation"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"We do a simple division: Remaining capacity (in Ah) / current draw (in A) \u2192 time in hours \u2192 then multiply by 60 for minutes."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"4-dealing-with-voltage-readings",children:(0,t.jsx)(n.strong,{children:"4. Dealing with Voltage Readings"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why Voltage?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Voltage alone isn\u2019t always an accurate gauge of battery capacity under load, but it still helps to monitor cell voltages (especially for LiPo) to avoid going below safe thresholds (e.g., 3.5V per cell under load)."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"If Using INA219 or Another Sensor"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Many of these sensors can measure bus voltage as well. You can read the battery voltage to ensure you don\u2019t drop below safe limits, or to calibrate your capacity usage if you notice heavy voltage sag."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"5-practical-considerations",children:(0,t.jsx)(n.strong,{children:"5. Practical Considerations"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Calibration"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hall-effect sensors"})," (like ACS712) have offsets that shift with temperature. You might want to calibrate (measure zero-current offset) at startup or occasionally in flight."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Noise Filtering"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Microcontrollers can pick up noise from high-current wires. Twisted wires, capacitors on sensor outputs, or software filtering can help stabilize readings."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Safety Margin"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Coulomb counting can drift over time if there\u2019s any error in measurement. Periodically checking voltage can provide a reality check (e.g., if the voltage is about to reach your cutoff, even if your coulomb count says there\u2019s capacity left)."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Integration in Drones"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If your flight controller supports sensor inputs or if you have a separate microcontroller (like an onboard \u201cbattery monitor module\u201d), you can feed the data into your main flight software or OSD (On-Screen Display) for real-time flight-time readouts."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Data Display"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Instead of printing to Serial, you could display real-time info on a small OLED, LCD screen, or transmit via a wireless link (e.g., telemetry radio, Bluetooth) to a ground station."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"6-summary",children:(0,t.jsx)(n.strong,{children:"6. Summary"})}),"\n",(0,t.jsx)(n.p,{children:"Implementing flight-time estimation on a microcontroller using a current sensor is essentially about:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reading Current"})," \u2013 either via an analog or digital sensor."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coulomb Counting"})," \u2013 integrating current over time to determine used capacity."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Estimating Remaining Capacity"})," \u2013 subtracting from your known (or adjusted) battery capacity."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Flight Time Calculation"})," \u2013 dividing remaining capacity by the current draw to determine how many minutes remain."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This approach gives you a more ",(0,t.jsx)(n.strong,{children:"real-time and accurate"})," estimation than voltage-based guesses alone, especially when your drone\u2019s current draw fluctuates rapidly. By adding logic for voltage checks and some sensor calibration, you can further refine and safeguard your battery monitoring system."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var i=r(6540);const t={},s=i.createContext(t);function l(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);